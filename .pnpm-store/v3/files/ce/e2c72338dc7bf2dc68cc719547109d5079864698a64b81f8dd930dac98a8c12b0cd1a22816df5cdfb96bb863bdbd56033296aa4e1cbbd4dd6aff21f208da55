/*!
 * Crafted with ❤ by Salla
 */
import { Host, h } from "@stencil/core";
export class SallaMultipleBundleProductOptionsModal {
    constructor() {
        this.product = null;
        this.sectionId = null;
        this.sectionIndex = 0;
        this.productIndex = 0;
        this.selectedOptions = {};
        this.isLoading = false;
        this.hasUnsavedChanges = false;
        this.validationErrors = [];
    }
    /**
     * Generate a unique cache key for selected options using section ID, product index, and product ID
     */
    generateCacheKey(sectionId, productIndex, productId) {
        return `${sectionId || 'unknown'}-${productIndex || 0}-${productId || 'unknown'}`;
    }
    handleProductChange(newValue) {
        // Use setTimeout to ensure modal is ready
        setTimeout(() => {
            if (this.modal && newValue) {
                const title = newValue.name || '';
                this.modal.setTitle(title);
            }
        }, 100);
        // Reset validation errors when product changes
        this.validationErrors = [];
        this.hasUnsavedChanges = false;
    }
    async open() {
        if (!this.modal) {
            requestAnimationFrame(() => this.open());
            return;
        }
        this.isLoading = true;
        // Set the title before opening
        if (this.product?.name) {
            this.modal.setTitle(this.product.name);
        }
        this.modal.open();
        // Initialize selectedOptions with current selections from the component
        setTimeout(async () => {
            if (this.product?.id) {
                await this.initializeSelectedOptions();
            }
            // Set title again after modal is fully loaded
            if (this.product?.name) {
                this.modal.setTitle(this.product.name);
            }
            this.modal.stopLoading();
            this.isLoading = false;
        }, 300);
    }
    async close() {
        if (this.modal) {
            this.modal.close();
        }
    }
    async refreshOptionsState() {
        // Force re-render by updating the component state
        this.selectedOptions = { ...this.selectedOptions };
    }
    componentDidLoad() {
        salla.event.on('multiple-bundle-product-modal::open', (data) => {
            this.product = data.product;
            this.sectionId = data.sectionId || null;
            this.sectionIndex = data.sectionIndex || 0;
            this.productIndex = data.productIndex || 0;
            this.open();
        });
        // Listen for clear-options event when a product is deselected
        salla.event.on('multiple-bundle-product-modal::clear-options', (data) => {
            this.clearProductOptions(data.productId);
        });
        // Create and store the option change listener for proper cleanup
        this.optionChangeListener = (e) => {
            const { productId, option, detail } = e.detail;
            // Convert productId to the same type as our product ID
            const normalizedProductId = this.product?.id ? String(this.product.id) : null;
            const normalizedEventProductId = productId ? String(productId) : null;
            // Only handle events for the current product
            if (normalizedProductId &&
                normalizedEventProductId &&
                normalizedProductId === normalizedEventProductId &&
                option &&
                detail) {
                this.handleOptionChange(Number(normalizedProductId), option, detail);
            }
        };
        salla.event.on('product-options::change', this.optionChangeListener);
        // Create and store the checkbox change listener for proper cleanup
        this.checkboxChangeListener = (e) => {
            const target = e.target;
            // Check if this is a product selection checkbox
            if (target && target.type === 'checkbox' && target.name && target.name.includes('bundle[') && target.name.includes('][id]')) {
                // Extract section info from the checkbox name: bundle[sectionId][productIndex][id]
                const nameMatch = target.name.match(/^bundle\[([^\]]+)\]\[([^\]]+)\]\[id\]$/);
                if (nameMatch && !target.checked) {
                    // Product was deselected, clear its cached options
                    const [, sectionId, productIndex] = nameMatch;
                    const productId = target.value;
                    // Prevent the immediate event to ensure cleanup happens first
                    e.preventDefault();
                    e.stopPropagation();
                    // Ensure the checkbox is actually unchecked
                    target.checked = false;
                    // Generate the same cache key used by the modal
                    const cacheKey = this.generateCacheKey(sectionId, parseInt(productIndex), productId);
                    // Clear the cached options for this product
                    const updatedSelectedOptions = { ...this.selectedOptions };
                    delete updatedSelectedOptions[cacheKey];
                    this.selectedOptions = updatedSelectedOptions;
                    // Force re-render of the modal if it's currently open for this product
                    if (this.product && this.product.id == productId) {
                        this.selectedOptions = { ...this.selectedOptions };
                    }
                    const form = this.host.closest('form');
                    if (form) {
                        const productInputPattern = `bundle[${sectionId}][${productIndex}]`;
                        // Get all form inputs and filter manually
                        const allInputs = Array.from(form.querySelectorAll('input'));
                        const matchingInputs = allInputs.filter(input => input.name && input.name.startsWith(productInputPattern));
                        // Process matching inputs for removal
                        matchingInputs.forEach(el => {
                            // Don't remove the visible checkbox that was just unchecked
                            if (el !== target && (el.type === 'hidden' || el.hasAttribute('data-product-id'))) {
                                el.remove();
                            }
                        });
                        // Method 2: Find inputs by data-product-id BUT only within the same section/productIndex
                        const dataProductInputs = allInputs.filter(input => {
                            // Must have data-product-id matching the productId
                            if (input.getAttribute('data-product-id') !== String(productId)) {
                                return false;
                            }
                            // Must also be within the same section/productIndex pattern
                            return input.name && input.name.startsWith(productInputPattern);
                        });
                        // Process inputs with matching section/productIndex and productId for removal
                        dataProductInputs.forEach(el => {
                            if (el !== target) {
                                el.remove();
                            }
                        });
                        // Method 3: Removed broader search to prevent removing inputs from other products
                        // The cleanup is now more precise and only removes inputs for the specific product
                        // Trigger form change event after cleanup is complete
                        setTimeout(() => {
                            const changeEvent = new window.Event('change', { bubbles: true });
                            form.dispatchEvent(changeEvent);
                        }, 50); // Small delay to ensure cleanup is complete
                    }
                }
            }
        };
        // Listen for product checkbox changes to reset options when product is deselected
        document.addEventListener('change', this.checkboxChangeListener);
    }
    disconnectedCallback() {
        // Clean up event listeners to prevent memory leaks
        if (this.checkboxChangeListener) {
            document.removeEventListener('change', this.checkboxChangeListener);
        }
    }
    generateFormInputName(sectionId, productIndex, optionParentId) {
        return `bundle[${sectionId}][${productIndex}][options][${optionParentId}]`;
    }
    async initializeSelectedOptions() {
        if (!this.product?.id)
            return;
        const productId = this.product.id;
        const cacheKey = this.generateCacheKey(this.sectionId, this.productIndex, productId);
        const optionsEl = document.querySelector(`salla-product-options[product-id="${productId}"]`);
        if (optionsEl) {
            try {
                const selectedOptions = await optionsEl.getSelectedOptions();
                if (selectedOptions && selectedOptions.length > 0) {
                    this.selectedOptions = {
                        ...this.selectedOptions,
                        [cacheKey]: selectedOptions,
                    };
                }
            }
            catch (e) {
                console.warn('Could not initialize selected options:', e);
            }
        }
    }
    // Clear options state for a specific product
    clearProductOptions(productId) {
        // Generate cache key for this specific product in current section context
        const cacheKey = this.generateCacheKey(this.sectionId, this.productIndex, productId);
        // Remove the product from selectedOptions using the cache key
        const updatedSelectedOptions = { ...this.selectedOptions };
        delete updatedSelectedOptions[cacheKey];
        this.selectedOptions = updatedSelectedOptions;
        // Reset validation errors and unsaved changes
        this.validationErrors = [];
        this.hasUnsavedChanges = false;
    }
    async handleOptionChange(productId, option, detail) {
        const cacheKey = this.generateCacheKey(this.sectionId, this.productIndex, productId);
        // Get the current state from the component to ensure we have the latest selections
        const optionsEl = document.querySelector(`salla-product-options[product-id="${productId}"]`);
        let currentComponentSelections = [];
        if (optionsEl) {
            try {
                currentComponentSelections = (await optionsEl.getSelectedOptions()) || [];
            }
            catch (e) {
                console.warn('Could not get current selections from component:', e);
            }
        }
        // If component returns data, use it; otherwise, fall back to manual tracking
        if (currentComponentSelections.length > 0) {
            // Component returned data, use it
            this.selectedOptions = {
                ...this.selectedOptions,
                [cacheKey]: currentComponentSelections,
            };
        }
        else {
            // If we have existing selections in internal state and component returns empty,
            // it might be a deselection, so we should use manual tracking
            if (this.selectedOptions[cacheKey] && this.selectedOptions[cacheKey].length > 0) {
                // Component didn't return data, use manual tracking
                const currentSelected = this.selectedOptions[cacheKey] || [];
                const updatedSelected = [...currentSelected];
                // Find existing selection for this specific option (by option_id)
                const existingIndex = updatedSelected.findIndex(opt => opt.option_id === option.id);
                if (existingIndex > -1) {
                    // Check if this is a deselection (detail might be null or undefined)
                    if (!detail || detail.id === null || detail.id === undefined) {
                        // Remove the option (deselection)
                        updatedSelected.splice(existingIndex, 1);
                    }
                    else {
                        // Replace existing selection for this option
                        updatedSelected[existingIndex] = { ...detail, option_id: option.id };
                    }
                }
                else {
                    // Only add if detail exists (not a deselection)
                    if (detail && detail.id !== null && detail.id !== undefined) {
                        updatedSelected.push({ ...detail, option_id: option.id });
                    }
                }
                this.selectedOptions = {
                    ...this.selectedOptions,
                    [cacheKey]: updatedSelected,
                };
            }
            else {
                // No existing selections, component returned empty, and we're trying to add
                // This might be the first selection, so add it manually
                if (detail && detail.id !== null && detail.id !== undefined) {
                    this.selectedOptions = {
                        ...this.selectedOptions,
                        [cacheKey]: [{ ...detail, option_id: option.id }],
                    };
                }
            }
        }
        this.hasUnsavedChanges = true;
        this.validationErrors = []; // Clear validation errors when user makes changes
    }
    async validateOptions() {
        if (!this.product?.options)
            return true;
        const errors = [];
        const productId = this.product.id;
        const cacheKey = this.generateCacheKey(this.sectionId, this.productIndex, productId);
        // Get the actual selected options from the component
        const optionsEl = document.querySelector(`salla-product-options[product-id="${productId}"]`);
        let currentSelected = [];
        if (optionsEl) {
            try {
                currentSelected = (await optionsEl.getSelectedOptions()) || [];
                // Also check our internal state as fallback
                const internalSelected = this.selectedOptions[cacheKey] || [];
                // Use whichever has more selections, or if component returns empty but internal has data, use internal
                if (internalSelected.length > currentSelected.length ||
                    (currentSelected.length === 0 && internalSelected.length > 0)) {
                    currentSelected = internalSelected;
                }
            }
            catch (e) {
                // Fallback to internal state
                currentSelected = this.selectedOptions[cacheKey] || [];
            }
        }
        else {
            // Fallback to internal state
            currentSelected = this.selectedOptions[cacheKey] || [];
        }
        // Check if any options are selected at all
        if (currentSelected.length === 0) {
            errors.push(salla.lang.get('pages.products.no_options_selected'));
        }
        // Check required options
        this.product.options.forEach(option => {
            if (option.required) {
                const hasSelection = currentSelected.some(selected => {
                    return selected.option_id == option.id; // Use == instead of === for type flexibility
                });
                if (!hasSelection) {
                    errors.push(salla.lang.get('pages.products.required_option_missing', {
                        option: option.name,
                    }));
                }
            }
        });
        this.validationErrors = errors;
        return errors.length === 0;
    }
    async onSave(e) {
        e.preventDefault();
        const productId = this.product?.id;
        if (!productId)
            return;
        const cacheKey = this.generateCacheKey(this.sectionId, this.productIndex, productId);
        // Small delay to ensure component state is updated
        await new Promise(resolve => setTimeout(resolve, 100));
        // Validate options before saving
        const isValid = await this.validateOptions();
        if (!isValid) {
            salla.notify.error(this.validationErrors.join(', '));
            return;
        }
        this.isLoading = true;
        try {
            // please don't change this with this.host.querySelector it will return null
            const optionsEl = document.querySelector(`salla-product-options[product-id="${productId}"]`);
            let selectedOptions = await optionsEl?.getSelectedOptions();
            // If component returns empty but we have internal state, use internal state
            if ((!selectedOptions || selectedOptions.length === 0) &&
                this.selectedOptions[cacheKey]?.length > 0) {
                selectedOptions = this.selectedOptions[cacheKey];
            }
            if (!selectedOptions || selectedOptions.length === 0) {
                this.isLoading = false;
                return;
            }
            // Store the selected options for this product using cache key
            this.selectedOptions = {
                ...this.selectedOptions,
                [cacheKey]: selectedOptions,
            };
            const form = this.host.closest('form');
            if (!form) {
                this.isLoading = false;
                return;
            }
            // remove old inputs for this specific product in this specific section/index only
            const productInputPattern = `bundle[${this.sectionId}][${this.productIndex}]`;
            // Remove only hidden inputs and inputs with data-product-id, but preserve visible checkboxes
            Array.from(form.querySelectorAll(`input[name^="${productInputPattern}"][type="hidden"]`)).forEach(el => el.remove());
            // Also remove any inputs with data-product-id that match this specific pattern
            Array.from(form.querySelectorAll(`[data-product-id="${productId}"][name^="${productInputPattern}"]`)).forEach(el => el.remove());
            // Ensure the actual checkbox in the UI is checked to reflect the selection visually
            const checkboxId = `bundle[${this.sectionId}][${this.productIndex}][id]`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox) {
                checkbox.checked = true;
                // Don't dispatch change event here to avoid double API calls
            }
            else {
                // If checkbox doesn't exist, create a hidden input as fallback
                const productSelectionInput = document.createElement('input');
                productSelectionInput.type = 'hidden';
                productSelectionInput.name = `bundle[${this.sectionId}][${this.productIndex}][id]`;
                productSelectionInput.value = String(productId);
                productSelectionInput.dataset.productId = String(productId);
                form.appendChild(productSelectionInput);
            }
            // append new hidden inputs for options
            selectedOptions.forEach((option) => {
                // how to get option parent id?
                const optionParentId = option.option_id;
                const hidden = document.createElement('input');
                hidden.type = 'hidden';
                // Use productIndex for the form input name
                hidden.name = this.generateFormInputName(this.sectionId, this.productIndex ?? 0, optionParentId);
                hidden.value = String(option.id);
                hidden.dataset.productId = String(productId);
                form.appendChild(hidden);
            });
            // Trigger single form change event with all updates (product selection + options)
            const changeEvent = new window.Event('change', { bubbles: true });
            form.dispatchEvent(changeEvent);
            // Emit custom event
            this.optionsSaved.emit({
                productId: Number(productId),
                selectedOptions,
            });
            // Emit product selected event to check the card
            if (this.sectionId) {
                this.productSelected.emit({
                    productId: Number(productId),
                    sectionId: this.sectionId,
                    product: this.product,
                    fromModal: true,
                });
            }
            // Show success message
            salla.notify.success(salla.lang.get('pages.products.options_saved'));
            this.hasUnsavedChanges = false;
            this.validationErrors = [];
            // close modal
            this.modal.close();
        }
        catch (error) {
            salla.notify.error(salla.lang.get('pages.products.options_save_error'));
        }
        finally {
            this.isLoading = false;
        }
    }
    // Method to get options with selected state preserved
    getOptionsWithSelectedState() {
        if (!this.product?.options)
            return [];
        const cacheKey = this.generateCacheKey(this.sectionId, this.productIndex, this.product.id);
        const savedOptions = this.selectedOptions[cacheKey] || [];
        return this.product.options.map(option => ({
            ...option,
            details: option.details.map(detail => {
                const isSelected = savedOptions.some(saved => {
                    return saved.id === detail.id;
                });
                return {
                    ...detail,
                    is_selected: isSelected,
                };
            }),
        }));
    }
    render() {
        const productId = this.product?.id;
        const optionsWithSelectedState = this.getOptionsWithSelectedState();
        return (h(Host, { key: '52efc988e52036a0be8c5dfe7d9375aed2072b55' }, h("salla-modal", { key: 'e07dd856effc65a718528c6836884cd82520e94e', isLoading: this.isLoading, ref: el => (this.modal = el), width: "md", centered: false, id: `s-multiple-bundle-product-options-modal-options-${productId}`, class: "s-multiple-bundle-product-options-modal-wrapper" }, h("div", { key: '5365b7d796d48759a8cd0e7bb7e6cd755382afc8', slot: "loading" }, h("salla-skeleton", { key: 'deb66b5f95587584ade5581da3c891a95d3750af', height: "100%", width: "100%" })), this.product?.images && this.product?.images.length > 0 && (h("salla-slider", { key: 'e79b63e49ba9c29ef9d625ca99ffd17bbf282f79', id: `details-slider-${this.product?.id}`, type: "thumbs", loop: false, "auto-height": true, "listen-to-thumbnails-option": true, showThumbsControls: false, controlsOuter: false, showControls: false, class: "s-multiple-bundle-product-options-modal-slider", verticalThumbs: true, thumbsConfig: {
                centeredSlides: true,
                centeredSlidesBounds: true,
                slidesPerView: Math.min(5, Math.max(1, this.product?.images.length)),
                watchOverflow: true,
                watchSlidesVisibility: true,
                watchSlidesProgress: true,
                direction: 'vertical',
                spaceBetween: 10,
            } }, h("div", { key: '3c3f3d2a1de4869a0d2d15583630d04a400097d7', slot: "items" }, this.product?.images &&
            this.product?.images.map((image, index) => (h("div", { key: index, class: "swiper-slide" }, h("img", { src: image.url, alt: image.alt || `${this.product?.name} - Image ${index + 1}`, loading: "lazy", onError: e => {
                    e.target.style.display = 'none';
                } }))))), this.product?.images && this.product?.images.length > 1 && (h("div", { key: '5d0f67677595c442d76f0fb3a42dacb1996e58db', slot: "thumbs" }, this.product?.images &&
            this.product?.images.map((image, index) => (h("div", { key: index, "data-caption": `${this.product?.name} - Image ${index + 1}` }, h("img", { src: image.url, loading: "eager", class: "s-multiple-bundle-product-options-modal-slider-thumb", title: `${this.product?.name} - ${index + 1}`, alt: image.alt || `${this.product?.name} - ${index + 1}`, onError: e => {
                    e.target.style.display = 'none';
                } })))))))), h("salla-product-options", { options: JSON.stringify(optionsWithSelectedState), key: `${this.sectionId}-${this.sectionIndex}-${productId}-persistent`, "product-id": productId }), h("div", { key: '1f166bdaf78a78b99aeecc141e6f99b9fa1e50b1', slot: "footer" }, h("div", { key: 'e4ea869eaf9690ee3aba7319f976a82f8187767e', class: "s-multiple-bundle-product-options-modal-footer" }, h("salla-button", { key: '17e4f97284528019b25bd640ff3843dbbefb5dae', onClick: e => this.onSave(e), loading: this.isLoading, disabled: this.isLoading }, this.isLoading
            ? salla.lang.get('common.elements.saving')
            : salla.lang.get('common.elements.save')))))));
    }
    static get is() { return "salla-multiple-bundle-product-options-modal"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["salla-multiple-bundle-product-options-modal.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["salla-multiple-bundle-product-options-modal.css"]
        };
    }
    static get states() {
        return {
            "product": {},
            "sectionId": {},
            "sectionIndex": {},
            "productIndex": {},
            "selectedOptions": {},
            "isLoading": {},
            "hasUnsavedChanges": {},
            "validationErrors": {}
        };
    }
    static get events() {
        return [{
                "method": "optionsSaved",
                "name": "optionsSaved",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "complexType": {
                    "original": "{ productId: number; selectedOptions: SelectedOption[] }",
                    "resolved": "{ productId: number; selectedOptions: SelectedOption[]; }",
                    "references": {
                        "SelectedOption": {
                            "location": "import",
                            "path": "../interfaces",
                            "id": "src/components/salla-multiple-bundle-product/interfaces.ts::SelectedOption"
                        }
                    }
                }
            }, {
                "method": "productSelected",
                "name": "productSelected",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "complexType": {
                    "original": "{\n    productId: number;\n    sectionId: string | number;\n    product?: BundleProduct;\n    fromModal?: boolean;\n  }",
                    "resolved": "{ productId: number; sectionId: string | number; product?: BundleProduct; fromModal?: boolean; }",
                    "references": {
                        "BundleProduct": {
                            "location": "import",
                            "path": "../interfaces",
                            "id": "src/components/salla-multiple-bundle-product/interfaces.ts::BundleProduct"
                        }
                    }
                }
            }];
    }
    static get methods() {
        return {
            "open": {
                "complexType": {
                    "signature": "() => Promise<void>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "close": {
                "complexType": {
                    "signature": "() => Promise<void>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "refreshOptionsState": {
                "complexType": {
                    "signature": "() => Promise<void>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "host"; }
    static get watchers() {
        return [{
                "propName": "product",
                "methodName": "handleProductChange"
            }];
    }
}
